# Руководство по разработке плагина Vibe Design

## Содержание

1. [Обзор](#обзор)
2. [Архитектура плагина](#архитектура-плагина)
3. [Интерфейс пользователя](#интерфейс-пользователя)
4. [Коммуникация с MCP-сервером](#коммуникация-с-mcp-сервером)
5. [Реализация инструментов](#реализация-инструментов)
6. [Тестирование плагина](#тестирование-плагина)
7. [Рекомендации по разработке](#рекомендации-по-разработке)
8. [План разработки](#план-разработки)
9. [Репозиторий и ветки](#репозиторий-и-ветки)

## Репозиторий и ветки

### Информация о репозитории

Проект размещен в репозитории на GitHub и организован с использованием веток для различных этапов разработки.

- **Основной репозиторий**: [https://github.com/neprokin/vibe-design](https://github.com/neprokin/vibe-design)
- **Статус проекта**: Активная разработка
- **Лицензия**: MIT License

### Структура веток

Разработка ведется в следующих ветках:

1. **`main`** - основная ветка, содержит стабильный код
   - Текущее состояние: Базовая структура проекта и документация
   - Точка слияния для прошедших проверку функциональностей

2. **`feature/mcp-server`** - ветка разработки MCP-сервера
   - Текущее состояние: MCP-сервер полностью разработан с поддержкой WebSocket и API для Figma
   - Включает интеграцию с AI, инструменты анализа дизайна и генерации кода

3. **`feature/figma-plugin-development`** - ветка разработки плагина Figma
   - Текущее состояние: Плагин разработан и готов к тестированию
   - Реализована полная функциональность для всех инструментов
   - WebSocket-соединение с MCP-сервером для обмена данными
   - Настройки плагина и обработка выбранных элементов

4. **`dev`** - ветка для интеграции всех изменений перед слиянием с main
   - Текущее состояние: Синхронизирована с main

### Порядок работы с ветками

1. Разработка новых функций выполняется в тематических ветках:
   - `feature/имя-функциональности` - для новых функций
   - `bugfix/имя-ошибки` - для исправления ошибок
   - `hotfix/имя-срочного-исправления` - для срочных исправлений

2. После завершения разработки:
   - Выполняется код-ревью
   - Проводится тестирование
   - Создается Pull Request в `dev`

3. После проверки в `dev`:
   - Изменения тестируются в интеграции с другими компонентами
   - При успешном тестировании код переносится в `main`

### Текущие разработки

- **Активная разработка**: Тестирование и отладка Figma-плагина
- **Закрытые этапы**: Базовая инфраструктура, инструменты для работы с Figma, AI-интеграция, документация, разработка основных компонентов плагина
- **Следующие этапы**: Тестирование и отладка плагина, подготовка к выпуску

## Обзор

Figma-плагин является ключевым компонентом системы, обеспечивающим взаимодействие между Figma и MCP-сервером. Он предоставляет пользовательский интерфейс для доступа к различным инструментам анализа дизайна, генерации кода и других функций, которые обрабатываются на стороне MCP-сервера с использованием AI.

### Ключевые функции плагина

1. **Подключение к MCP-серверу**:
   - Установка и управление WebSocket-соединением
   - Обработка сетевых ошибок и повторные подключения
   - Индикация статуса соединения

2. **Управление дизайн-элементами**:
   - Получение информации о выбранных элементах
   - Отправка данных в MCP-сервер
   - Применение изменений к элементам дизайна

3. **Инструменты анализа и генерации**:
   - Анализ дизайна (UX/UI, доступность)
   - Генерация кода
   - Генерация адаптивных макетов
   - Генерация вариантов компонентов

4. **Пользовательский интерфейс**:
   - Панель инструментов
   - Настройки для каждого инструмента
   - Отображение результатов
   - Индикаторы прогресса

## Архитектура плагина

### Текущее состояние плагина

#### Основные компоненты (✅ Реализовано)
- [x] **Базовая инфраструктура**: настроена структура проекта, конфигурация TypeScript, сборка с Webpack
- [x] **WebSocket клиент**: реализован и протестирован для связи с MCP-сервером
- [x] **Пользовательский интерфейс**: разработан базовый UI с React-компонентами
- [x] **DebugPanel**: создана панель отладки для мониторинга событий и логов
- [x] **EventService**: сервис для обработки событий и связи с сервером
- [x] **NodeUpdater**: сервис для обновления узлов в Figma
- [x] **TestService**: сервис для тестирования соединения и функций плагина
- [x] **Система типов**: разработаны типы для событий и сообщений UI
- [x] **Система логирования**: реализовано журналирование событий с возможностью просмотра в DebugPanel

#### Основная функциональность
- [x] **Соединение с сервером**: установка/разрыв WebSocket-соединения
- [x] **PING/PONG**: тестирование соединения и измерение задержки
- [x] **Получение данных выбора**: извлечение информации о выбранных элементах
- [x] **Обработка UPDATE_NODE**: обновление свойств узлов через команды от сервера
- [x] **Система логирования**: фиксация и отображение событий и ошибок
- [x] **Тестирование функций**: возможность проверки работы основных компонентов

#### Текущая архитектура плагина

##### Общая структура
Плагин Figma использует модель с разделением на:
1. **Код плагина** (`plugin.ts`) - запускается в среде Figma и имеет доступ к Figma API
2. **Интерфейс пользователя** (`ui.tsx`) - запускается в iframe и общается с плагином через сообщения

##### Компоненты плагина
1. **EventService** - центральный компонент для обработки событий и связи с сервером
   - Управление WebSocket-соединением
   - Отправка/получение событий
   - Обработка ответов
   - Регистрация обработчиков событий

2. **DebugPanel** - компонент для отображения логов и отладочной информации
   - Показ истории событий
   - Отображение статуса соединения
   - Возможность фильтрации логов
   - Управление видимостью

3. **NodeUpdater** - сервис для обновления узлов в Figma
   - Подготовка данных для обновления
   - Обработка команд UPDATE_NODE
   - Валидация свойств

4. **TestService** - инструменты для тестирования
   - Проверка соединения через PING
   - Тестирование обновления узлов
   - Измерение производительности

##### Система типов
В плагине реализованы следующие основные типы:
1. **События** (`events.ts`) - определяют формат данных для обмена с сервером
   - FigmaEventType - перечисление типов событий
   - FigmaEvent - базовый интерфейс события
   - Специализированные типы событий (PING, UPDATE_NODE, и т.д.)

2. **UI сообщения** (`ui-messages.ts`) - определяют формат сообщений между UI и кодом плагина
   - UIMessage - базовый интерфейс сообщения
   - Типы для подключения, обновления, логирования и т.д.

## Готовность функциональности

### Реализовано и протестировано
- [x] **Установка WebSocket-соединения**: успешно устанавливается соединение с MCP-сервером
- [x] **Проверка соединения**: обмен PING/PONG сообщениями работает корректно
- [x] **Получение данных выбора**: информация о выбранных элементах успешно извлекается
- [x] **Отображение логов**: панель отладки показывает все события и сообщения
- [x] **Базовое обновление узлов**: команды UPDATE_NODE обрабатываются корректно

### Требует доработки
- [ ] **Автоматическое восстановление соединения**: при обрыве связи
- [ ] **Расширенная фильтрация логов**: по типу, времени, источнику
- [ ] **Экспорт/импорт логов**: для детального анализа
- [ ] **Улучшение UI**: более удобный и информативный интерфейс
- [ ] **Обработка множественного выбора**: корректная работа с несколькими выбранными элементами

### Требует реализации
- [ ] **Интеграция с AI-функциями**: анализ дизайна, генерация кода
- [ ] **Работа с дизайн-системой**: переменные, компоненты, стили
- [ ] **Генерация адаптивных макетов**: создание вариантов для разных устройств
- [ ] **Расширенная аналитика**: проверка доступности, контрастности, типографики
- [ ] **Интеграция с Cursor**: для генерации кода и синхронизации

## Структура проекта

```
figma_plugin/
├── src/
│   ├── components/               # React-компоненты
│   │   ├── DebugPanel.tsx        # Панель отладки
│   │   └── ...                   # Другие компоненты
│   ├── services/                 # Сервисы
│   │   ├── event-service.ts      # Обработка событий
│   │   ├── node-updater.ts       # Обновление узлов
│   │   └── test-service.ts       # Тестирование
│   ├── types/                    # Типы и интерфейсы
│   │   ├── events.ts             # Типы событий
│   │   └── ui-messages.ts        # Типы сообщений UI
│   ├── plugin.ts                 # Код плагина
│   ├── ui.tsx                    # Интерфейс пользователя
│   └── ui.html                   # HTML-шаблон
├── ui.css                        # Стили интерфейса
├── manifest.json                 # Манифест плагина
├── package.json                  # Зависимости
└── tsconfig.json                 # Настройки TypeScript
```

## Руководство по запуску и отладке

### Установка и запуск
1. **Сборка плагина**:
   ```bash
   cd figma_plugin
   npm install
   npm run build
   ```

2. **Запуск MCP-сервера**:
   ```bash
   cd mcp_server
   python server.py
   ```

3. **Загрузка плагина в Figma**:
   - Откройте Figma
   - Перейдите в меню Plugins > Development > Import plugin from manifest...
   - Выберите файл manifest.json из директории figma_plugin

### Отладка плагина
1. **Просмотр логов**:
   - Используйте DebugPanel в интерфейсе плагина
   - Включите опцию отладки в плагине (консоль браузера)

2. **Перезапуск при изменениях**:
   - При внесении изменений выполните `npm run build`
   - В Figma: Plugins > Development > [Имя плагина] > Update

3. **Тестирование соединения**:
   - Используйте кнопку "Test Ping" для проверки соединения
   - Проверьте время отклика в логах

4. **Тестирование обновления узлов**:
   - Выберите элемент в Figma
   - Используйте кнопку "Test Node Update"
   - Проверьте изменения в выбранном элементе

## Рекомендации по разработке

### Лучшие практики
1. **Типизация**:
   - Всегда определяйте типы для событий и сообщений
   - Используйте строгую типизацию для всех функций

2. **Обработка ошибок**:
   - Оборачивайте вызовы Figma API в try/catch
   - Логируйте все ошибки в системе логирования

3. **UI компоненты**:
   - Разделяйте UI на маленькие, переиспользуемые компоненты
   - Используйте React Hooks для управления состоянием

4. **Производительность**:
   - Минимизируйте обмен данными между плагином и UI
   - Оптимизируйте рендеринг компонентов React

### Работа с Figma API
1. **Доступ к выбранным элементам**:
   ```typescript
   const selection = figma.currentPage.selection;
   ```

2. **Обновление свойств узла**:
   ```typescript
   if (node.type === 'TEXT') {
     node.characters = 'Новый текст';
   }
   ```

3. **Создание элементов**:
   ```typescript
   const rect = figma.createRectangle();
   rect.x = 100;
   rect.y = 100;
   rect.resize(200, 200);
   figma.currentPage.appendChild(rect);
   ```

4. **Отправка сообщения в UI**:
   ```typescript
   figma.ui.postMessage({ type: 'UPDATE_STATUS', status: 'success' });
   ```

## Дальнейшие шаги по развитию плагина

### Ближайшие задачи
1. **Улучшение обработки событий**:
   - Автоматическое восстановление соединения
   - Очередь сообщений при отсутствии связи
   - Оптимизация обмена данными

2. **Расширение UI**:
   - Добавление вкладок для разных функций
   - Интерактивные элементы управления
   - Визуализация результатов анализа

3. **Интеграция с AI**:
   - Подключение к инструментам анализа дизайна
   - Получение и отображение результатов
   - Применение рекомендаций AI

4. **Работа с дизайн-системой**:
   - Извлечение и анализ переменных
   - Работа с компонентами и их вариантами
   - Управление стилями

### Долгосрочные планы
1. **Полная интеграция с MCP-инструментами**:
   - Двусторонняя синхронизация с AI
   - Автоматическое применение изменений

2. **Генерация кода**:
   - Создание React/Vue/Angular компонентов
   - Интеграция с Tailwind CSS
   - Интеграция с shadcn/ui

3. **Адаптивный дизайн**:
   - Генерация вариантов для разных устройств
   - Проверка респонсивности
   - Рекомендации по улучшению

4. **Расширенная аналитика**:
   - Детальный анализ доступности
   - Проверка контрастности
   - Анализ типографики и визуальной иерархии

## План разработки

### Текущий статус (Март 2024)

- [x] Настройка инфраструктуры плагина
- [x] Базовое WebSocket-соединение с MCP-сервером
- [x] Компоненты пользовательского интерфейса (Header, Toolbar, Settings, Results)
- [x] Обработка выбранных элементов Figma
- [x] Реализация инструментов (анализ дизайна, генерация кода, адаптивные макеты, варианты)
- [x] Система управления настройками
- [ ] Тестирование и отладка в среде Figma
- [ ] Оптимизация и улучшение пользовательского опыта
- [ ] Подготовка к выпуску

### Следующие шаги

1. **Тестирование и отладка плагина**:
   - Тестирование в режиме разработки в Figma
   - Исправление ошибок типизации и интеграции с Figma API
   - Улучшение обработки ошибок и граничных случаев

2. **Улучшение пользовательского опыта**:
   - Добавление подсказок и руководства
   - Оптимизация рабочих процессов и потоков данных
   - Улучшение вывода результатов и интерактивности

3. **Подготовка к выпуску**:
   - Создание иконки и материалов для публикации
   - Написание документации для пользователей
   - Создание демонстрационных видео 

## Отладка WebSocket взаимодействия с MCP-сервером

### Типичные проблемы и решения

#### 1. Проблема: Сообщения от плагина не обрабатываются на сервере

Если вы видите в логах сервера сообщения вида `Received unknown message type: MESSAGE_TYPE`, это означает, что для данного типа сообщения не зарегистрирован обработчик.

**Решение:**
1. Проверьте регистрацию обработчиков на сервере:
   ```python
   # В файле mcp_server/server.py, перед запуском сервера
   ws_server.message_handlers["MESSAGE_TYPE"] = handle_message_function
   ```

2. Убедитесь, что тип сообщения в плагине совпадает с ожидаемым на сервере:
   ```javascript
   // Figma-плагин
   ws.send(JSON.stringify({
     type: "MESSAGE_TYPE", // Должно точно совпадать с типом на сервере
     payload: { /* данные */ }
   }));
   ```

#### 2. Проблема: Не удается подключиться к WebSocket серверу

**Решение:**
1. Проверьте, запущен ли MCP-сервер: `lsof -i :8768`
2. Убедитесь, что используется правильный адрес и порт: `ws://localhost:8768`
3. Проверьте логи сервера на наличие ошибок при запуске

#### 3. Проблема: Некорректная генерация кода

Если сервер возвращает ошибку при генерации кода из шаблона, возможно проблема в несоответствии параметров.

**Решение:**
1. Проверьте параметры, ожидаемые шаблоном (например, в `generate_code.j2`)
2. Убедитесь, что в контексте промпта используются правильные ключи:
   ```python
   # Должно быть
   prompt_context = {
     "design_data": figma_data,  # Имя параметра должно соответствовать шаблону
     # ...
   }
   ```

### Инструменты для отладки

#### 1. Тестовый WebSocket клиент

Создайте простой скрипт для тестирования WebSocket соединения и отправки сообщений:

```javascript
// test_websocket.js
const WebSocket = require('ws');
const serverUrl = 'ws://localhost:8768';
const ws = new WebSocket(serverUrl);

ws.onopen = function() {
    console.log('Подключено к серверу');
    
    // Отправка тестового сообщения
    ws.send(JSON.stringify({
        type: "GENERATE_CODE_REQUEST",
        payload: {
            designData: {
                // Тестовые данные
                name: "TestComponent",
                type: "FRAME",
                width: 200,
                height: 100,
                backgroundColor: "#FFFFFF",
                children: []
            },
            framework: "react",
            cssFramework: "tailwind"
        }
    }));
};

ws.onmessage = function(event) {
    const data = JSON.parse(event.data);
    console.log('Получено сообщение:', data.type);
    console.log('Данные:', JSON.stringify(data.payload, null, 2));
};

ws.onerror = function(error) {
    console.error('Ошибка WebSocket:', error);
};

ws.onclose = function(event) {
    console.log(`Соединение закрыто, код: ${event.code}, причина: ${event.reason || 'Не указана'}`);
};
```

#### 2. Мониторинг WebSocket соединений в плагине

Добавьте в UI плагина панель для отображения статуса WebSocket соединения:

```typescript
// В компоненте UI плагина
const [connectionStatus, setConnectionStatus] = useState<{
  connected: boolean;
  lastPing: number;
  messageCount: number;
}>({
  connected: false,
  lastPing: 0,
  messageCount: 0
});

// Обновление статуса при получении сообщений
useEffect(() => {
  const handleServerMessage = (event: MessageEvent) => {
    const data = JSON.parse(event.data);
    
    setConnectionStatus(prev => ({
      ...prev,
      messageCount: prev.messageCount + 1,
      lastPing: data.type === 'PONG' ? Date.now() : prev.lastPing
    }));
    
    // Обработка сообщения...
  };
  
  wsClient.addEventListener('message', handleServerMessage);
  return () => wsClient.removeEventListener('message', handleServerMessage);
}, [wsClient]);

// Отображение в UI
return (
  <div>
    <div className="connection-status">
      <span className={`status-indicator ${connectionStatus.connected ? 'connected' : 'disconnected'}`}></span>
      <span>Статус: {connectionStatus.connected ? 'Подключено' : 'Отключено'}</span>
      <span>Сообщений: {connectionStatus.messageCount}</span>
      <span>Последний пинг: {connectionStatus.lastPing > 0 ? new Date(connectionStatus.lastPing).toLocaleTimeString() : 'Н/Д'}</span>
    </div>
    {/* Остальной UI */}
  </div>
);
```

### Рекомендации по отладке WebSocket соединений

1. **Регулярно проверяйте соединение**
   - Отправляйте PING-сообщения с фронтенда и ожидайте PONG в ответ
   - Установите таймаут для обнаружения обрывов соединения

2. **Логируйте сообщения на обеих сторонах**
   - В плагине отображайте лог отправленных и полученных сообщений
   - На сервере логируйте все входящие сообщения и их обработку

3. **Используйте структурированные сообщения**
   - Всегда включайте поле `type` для идентификации сообщения
   - Помещайте данные в поле `payload`
   - Добавляйте дополнительные метаданные (timestamp, session_id) для отладки

4. **Обрабатывайте ошибки на обеих сторонах**
   - Отправляйте понятные сообщения об ошибках с сервера на клиент
   - Реализуйте механизм повторных попыток для нестабильных соединений 