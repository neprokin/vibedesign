# Руководство по рабочим процессам

## Введение

Данное руководство описывает основные рабочие процессы и методики использования интеграции Figma с AI через MCP-сервер. Руководство будет полезно как дизайнерам, так и разработчикам, которые хотят оптимизировать свои рабочие процессы и улучшить качество дизайна с помощью AI.

## Содержание

1. [Подготовка среды](#подготовка-среды)
2. [Процесс разработки](#процесс-разработки)
3. [Процесс тестирования](#процесс-тестирования)
4. [Интеграция с Figma](#интеграция-с-figma)
5. [Интеграция с разработкой](#интеграция-с-разработкой)
6. [Расширенные сценарии](#расширенные-сценарии)
7. [Устранение проблем](#устранение-проблем)
8. [Публикация и управление изменениями в Git](#публикация-и-управление-изменениями-в-git)

## Подготовка среды

Перед началом работы необходимо настроить окружение и установить все необходимые компоненты.

### Установка и настройка MCP-сервера

1. Клонирование репозитория
2. Установка зависимостей
3. Настройка API-ключей
4. Запуск сервера

Детальные инструкции по установке MCP-сервера приведены в [Руководстве по установке](DEPLOYMENT_GUIDE.md).

### Настройка и запуск Figma-плагина

1. Импорт плагина в Figma
2. Настройка подключения к MCP-серверу
3. Проверка функциональности

## Процесс разработки

### Общая схема работы

1. **Дизайн в Figma**:
   - Создание или выбор элементов дизайна
   - Выбор элементов для анализа или генерации

2. **Использование плагина**:
   - Подключение к MCP-серверу
   - Выбор инструмента (анализ, генерация, и т.д.)
   - Настройка параметров
   - Выполнение операции

3. **Обработка результатов**:
   - Просмотр результатов анализа
   - Внесение изменений на основе рекомендаций
   - Применение сгенерированного кода
   - Итеративное улучшение

### Тестирование соединения и системы

Перед началом активного использования рекомендуется проверить соединение и функциональность системы:

1. **Проверка соединения с сервером**:
   - Запустите MCP-сервер
   - Откройте плагин в Figma
   - Введите адрес сервера (по умолчанию ws://localhost:8767)
   - Нажмите кнопку "Connect"
   - Проверьте индикатор соединения (должен стать зеленым)

2. **Тестирование PING/PONG**:
   - После установки соединения нажмите кнопку "Test Ping"
   - В панели отладки (Debug Panel) проверьте результат
   - Убедитесь, что получен ответ PONG от сервера
   - Обратите внимание на время отклика (латентность)

3. **Тестирование обновления узлов**:
   - Выберите простой элемент в Figma (например, текстовый блок)
   - Нажмите кнопку "Test Node Update"
   - Проверьте изменение элемента в Figma
   - В панели отладки изучите процесс обмена сообщениями между плагином и сервером

4. **Расширенное тестирование (опционально)**:
   - Для проверки стабильности системы используйте кнопку "Start Automated Test"
   - Тесты будут выполняться автоматически с определенным интервалом
   - Для остановки тестирования нажмите "Stop Automated Test"
   - Проанализируйте результаты тестов в панели отладки

### Мониторинг и отладка процессов

Панель отладки (Debug Panel) является мощным инструментом для мониторинга и отладки:

1. **Мониторинг событий**:
   - Все события между плагином и сервером логируются в панели отладки
   - Каждое событие содержит метку времени, тип и содержимое
   - События отображаются в хронологическом порядке (снизу вверх)

2. **Отладка ошибок**:
   - Ошибки выделяются красным цветом
   - При возникновении ошибки проверьте:
     - Статус соединения с сервером
     - Правильность выбора элементов
     - Корректность настроек инструмента
     - Логи на стороне сервера

3. **Анализ производительности**:
   - Обратите внимание на время выполнения операций
   - Длительные операции (более 5 секунд) могут указывать на проблемы
   - При генерации сложного контента время выполнения может быть больше

## Процесс тестирования

### Проверка базовой функциональности

1. **Анализ дизайна**:
   - Выберите простой элемент (кнопка, поле ввода)
   - Запустите анализ дизайна
   - Проверьте наличие рекомендаций
   - Убедитесь, что рекомендации актуальны и применимы

2. **Генерация кода**:
   - Выберите компонент
   - Запустите генерацию кода
   - Проверьте качество сгенерированного кода
   - Протестируйте код в реальном проекте

3. **Адаптивные макеты**:
   - Выберите настольный макет
   - Запустите генерацию адаптивных версий
   - Проверьте корректность адаптации
   - Внесите необходимые корректировки

### Тестирование производительности

1. **Масштабирование**:
   - Тестирование на различных размерах проектов
   - Анализ времени выполнения операций
   - Определение оптимальных размеров выборки для анализа

2. **Нагрузочное тестирование**:
   - Запуск серии последовательных операций
   - Мониторинг использования ресурсов сервера
   - Проверка стабильности работы при длительном использовании

## Интеграция с Figma

### Работа с библиотеками компонентов

1. Анализ существующих библиотек
2. Генерация новых компонентов
3. Обновление компонентов на основе рекомендаций

### Работа с дизайн-системами

1. Анализ соответствия дизайн-системе
2. Улучшение согласованности дизайна
3. Документирование компонентов и стилей

## Интеграция с разработкой

### Экспорт и использование кода

1. Генерация кода компонентов
2. Интеграция в рабочий процесс разработки
3. Синхронизация изменений

### Автоматизация процессов

1. Настройка автоматических проверок
2. Интеграция с системами CI/CD
3. Автоматическая генерация кода при изменении дизайна

## Расширенные сценарии

### Сценарий 1: Комплексный анализ дизайна

1. Выбор всех компонентов интерфейса
2. Многоаспектный анализ (UX/UI, доступность, соответствие дизайн-системе)
3. Приоритизация и применение рекомендаций
4. Итеративная проверка улучшений

### Сценарий 2: Создание адаптивной дизайн-системы

1. Анализ существующих компонентов
2. Генерация адаптивных версий компонентов
3. Документирование правил адаптации
4. Тестирование на различных размерах экранов

### Сценарий 3: Быстрое прототипирование

1. Генерация базовых компонентов на основе текстового описания
2. Комбинирование компонентов в прототип
3. Анализ и улучшение прототипа
4. Генерация кода для быстрой реализации

### Сценарий 4: Автоматизированное тестирование и отладка

1. **Настройка среды тестирования**:
   - Запустите MCP-сервер в режиме отладки:
     ```bash
     cd mcp_server
     python server.py --debug
     ```
   - Откройте плагин в Figma и подключитесь к серверу
   - Убедитесь, что Debug Panel включена и отображается

2. **Создание тестового набора элементов**:
   - Создайте в Figma простой набор элементов: текст, кнопка, поле ввода, пиктограмма
   - Организуйте их в фрейме с названием "Test Components"
   - Добавьте варианты состояний для интерактивных элементов (hover, active, disabled)

3. **Систематическое тестирование функций**:
   - Используйте кнопку "Test Ping" для проверки соединения
   - Выберите текстовый элемент и проведите тест обновления узла
   - Проверьте функцию анализа дизайна на отдельных элементах
   - Протестируйте генерацию кода для различных компонентов

4. **Мониторинг и анализ процессов**:
   - В панели отладки отслеживайте все события и обмен сообщениями
   - Анализируйте время выполнения операций и причины задержек
   - Проверяйте соответствие входных и выходных данных

5. **Отладка проблем**:
   - При возникновении ошибок сразу фиксируйте контекст
   - Проверяйте логи сервера для получения дополнительной информации
   - Используйте возможность одновременного мониторинга клиентской и серверной части

6. **Документирование результатов**:
   - Ведите журнал тестирования с указанием успешных и проблемных сценариев
   - Фиксируйте воспроизводимые ошибки и условия их появления
   - Создавайте базу знаний для типичных проблем и их решений

## Устранение проблем

### Проблемы с подключением

1. Проверка запуска сервера
2. Проверка сетевых настроек
3. Проверка прав доступа

### Проблемы с анализом дизайна

1. Ограничения на сложность анализируемых элементов
2. Проверка полноты данных
3. Корректировка параметров анализа

### Проблемы с генерацией кода

1. Ограничения на компоненты, поддерживающие генерацию кода
2. Проверка качества исходного дизайна
3. Корректировка параметров генерации

## Отладка WebSocket соединений и обработчиков

### Регистрация обработчиков WebSocket сообщений

В MCP-сервере для регистрации обработчиков WebSocket сообщений есть два способа:

#### 1. Декораторы (может быть проблематично в некоторых случаях)

```python
@ws_server.register_handler("MESSAGE_TYPE")
async def handle_message(websocket, payload):
    # Обработка сообщения
    pass
```

#### 2. Прямая регистрация (более надежный способ)

```python
# Определение функции-обработчика
async def handle_message(websocket, payload):
    # Обработка сообщения
    pass

# Регистрация обработчика в словаре message_handlers
ws_server.message_handlers["MESSAGE_TYPE"] = handle_message
```

Важно регистрировать обработчики **до** запуска WebSocket сервера (вызова `ws_server.start(port)`).

### Тестирование WebSocket соединения

Для проверки работоспособности WebSocket сервера и отладки обработчиков сообщений рекомендуется использовать тестовый скрипт:

```javascript
// test_websocket.js
const WebSocket = require('ws');

// Адрес WebSocket сервера
const serverUrl = 'ws://localhost:8768';
console.log(`Connecting to server at ${serverUrl}...`);

// Создаем WebSocket соединение
const ws = new WebSocket(serverUrl);

// Обработчик открытия соединения
ws.onopen = function() {
    console.log('Connected to server');
    
    // Отправка PING сообщения для проверки соединения
    console.log('Sending PING message...');
    ws.send(JSON.stringify({
        type: 'PING',
        payload: {
            time: new Date().toISOString()
        }
    }));
    
    // Через 2 секунды отправляем тестовое сообщение
    setTimeout(() => {
        console.log('Sending TEST_MESSAGE...');
        ws.send(JSON.stringify({
            type: 'TEST_MESSAGE',
            payload: {
                // Данные сообщения
            }
        }));
    }, 2000);
};

// Обработчик сообщений
ws.onmessage = function(event) {
    try {
        const message = JSON.parse(event.data);
        console.log('Received message:', message.type);
        console.log('Payload:', JSON.stringify(message.payload, null, 2));
    } catch (e) {
        console.error('Error processing message:', e);
    }
};

// Обработчик ошибок
ws.onerror = function(error) {
    console.error('WebSocket error:', error);
};

// Обработчик закрытия соединения
ws.onclose = function(event) {
    console.log(`Connection closed with code ${event.code}, reason: ${event.reason || 'No reason'}`);
    process.exit(0);
};
```

Запустите скрипт командой:

```bash
npm install ws && node test_websocket.js
```

### Диагностика проблем с WebSocket

1. **Проверка занятости порта**:
   ```bash
   lsof -i :8768
   ```

2. **Остановка всех процессов, использующих порт**:
   ```bash
   pkill -f "python server.py"
   # или для конкретного PID
   kill -9 <PID>
   ```

3. **Проверка логов сервера** на наличие ошибок:
   - `Error starting WebSocket server: [Errno 48] address already in use` - порт уже занят другим процессом
   - `Received unknown message type: MESSAGE_TYPE` - сообщение не имеет зарегистрированного обработчика

4. **Отладка обработчиков шаблонов**:
   Если получаете ошибки типа `Object of type Undefined is not JSON serializable`, проверьте соответствие имен параметров, ожидаемых шаблоном, с теми, которые передаются в контекст шаблона.

## Публикация и управление изменениями в Git

### Процедура коммита изменений

1. **Подготовка коммита**:
   ```bash
   # Проверить статус измененных файлов
   git status
   
   # Добавить файлы для коммита
   git add <имя_файла>           # добавить конкретный файл
   git add -A                    # добавить все изменения
   ```

2. **Создание коммита**:
   ```bash
   # Создать коммит с информативным сообщением
   git commit -m "категория: краткое описание изменений"
   ```
   
   Категории коммитов:
   - `feat`: новая функциональность
   - `fix`: исправление ошибок
   - `docs`: изменения в документации
   - `refactor`: рефакторинг кода
   - `test`: добавление или исправление тестов
   - `chore`: обновления конфигурации, сборки и т.п.

3. **Публикация изменений**:
   ```bash
   # Синхронизация с удаленным репозиторием
   git pull origin <текущая_ветка>
   
   # Отправка изменений
   git push origin <текущая_ветка>
   ```

### Создание и слияние веток

1. **Создание новой ветки**:
   ```bash
   # Переключиться на develop
   git checkout develop
   
   # Создать и переключиться на новую ветку
   git checkout -b feature/имя-функциональности
   ```

2. **Слияние через Pull Request**:
   - Создание PR через GitHub интерфейс
   - Назначение ревьюеров
   - Проверка автоматических тестов
   - Слияние после получения одобрения

3. **Очистка после слияния**:
   ```bash
   # Переключиться на develop
   git checkout develop
   
   # Обновить develop
   git pull origin develop
   
   # Удалить локальную ветку
   git branch -d feature/имя-функциональности
   
   # Удалить удаленную ветку (опционально)
   git push origin --delete feature/имя-функциональности
   ```

### Используемые ветки в проекте

В проекте используется следующая структура веток:

1. **`main`** - основная ветка, содержащая стабильный код
   - Содержит версии, готовые к выпуску
   - Обновляется только через Pull Request из `develop`
   - Защищена от прямых изменений

2. **`develop`** - основная ветка разработки
   - Содержит актуальную версию кода в разработке
   - Все новые функции сначала интегрируются сюда
   - Служит основой для создания функциональных веток

3. **Функциональные ветки**:
   - `feature/mcp-server` - разработка MCP-сервера
   - `feature/figma-plugin` - разработка Figma-плагина
   - `feature/имя-новой-функции` - для новых функций
   - `bugfix/имя-ошибки` - для исправления ошибок
   - `hotfix/срочное-исправление` - для срочных исправлений в `main`

4. **Правила именования веток**:
   - Используйте префиксы для обозначения типа ветки: `feature/`, `bugfix/`, `hotfix/`
   - Используйте осмысленные, короткие названия
   - Разделяйте слова дефисами: `feature/websocket-integration`
   - Привязывайте ветки к задачам в трекере: `feature/login-form-task-123`

5. **Жизненный цикл веток**:
   - Функциональные ветки создаются из `develop`
   - После завершения работы сливаются обратно в `develop` через Pull Request
   - После слияния функциональные ветки удаляются
   - Исправления для выпущенных версий создаются из `main` (hotfix) и сливаются в обе ветки `main` и `develop`

### Проверка и отладка

1. **Проверка веток и состояния**:
   ```bash
   # Проверить все локальные ветки
   git branch
   
   # Проверить все удаленные ветки
   git branch -r
   
   # Проверить статус синхронизации
   git fetch
   git status
   ```

2. **Разрешение конфликтов**:
   - При возникновении конфликтов слияния:
     - Открыть конфликтующие файлы и решить конфликты
     - После разрешения: `git add <файл>` для каждого файла
     - Завершить слияние: `git commit`

### Лучшие практики

1. **Регулярная синхронизация**:
   - Периодически выполнять `git pull origin develop` для получения последних изменений
   - Решать конфликты сразу при их возникновении

2. **Атомарные коммиты**:
   - Каждый коммит должен содержать логически связанные изменения
   - Избегать объединения разных функциональностей в одном коммите

3. **Информативные сообщения**:
   - Сообщения коммитов должны ясно описывать внесенные изменения
   - Соблюдать структуру: "{тип}: {описание}"
   - При необходимости добавлять развернутое описание в теле коммита

## Заключение

Правильно организованный рабочий процесс позволяет максимально эффективно использовать возможности интеграции Figma с AI через MCP-сервер, значительно ускоряя процессы дизайна и разработки, повышая качество результатов и обеспечивая лучшую согласованность между дизайном и кодом. 